const app={canvasMain:null,ctxMain:null,canvasIntegral:null,ctxIntegral:null,canvasDerivative:null,ctxDerivative:null,params:{a:1,b:1,c:1,d:1,q:1},clickedPoints:{main:null,integral:null,derivative:null},init(){this.canvasMain=document.getElementById("main-plot"),this.ctxMain=this.canvasMain.getContext("2d"),this.canvasIntegral=document.getElementById("integral-plot"),this.ctxIntegral=this.canvasIntegral.getContext("2d"),this.canvasDerivative=document.getElementById("derivative-plot"),this.ctxDerivative=this.canvasDerivative.getContext("2d"),this.setupClickListeners(),this.setupParamSliders(),this.plot()},setupClickListeners(){const handleCanvasClick=(canvas,canvasType)=>{canvas.addEventListener("click",event=>{const rect=canvas.getBoundingClientRect(),scaleX=canvas.width/rect.width,scaleY=canvas.height/rect.height,x=(event.clientX-rect.left)*scaleX,y=(event.clientY-rect.top)*scaleY;this.clickedPoints[canvasType]={x:x,y:y},this.plot()})};handleCanvasClick(this.canvasMain,"main"),handleCanvasClick(this.canvasIntegral,"integral"),handleCanvasClick(this.canvasDerivative,"derivative")},setupParamSliders(){["a","b","c","d","q"].forEach(param=>{const slider=document.getElementById(`param-${param}-slider`),minInput=document.getElementById(`param-${param}-min`),maxInput=document.getElementById(`param-${param}-max`),valueDisplay=document.getElementById(`param-${param}-value`),updateSliderRange=()=>{const min=parseFloat(minInput.value),max=parseFloat(maxInput.value);slider.min=min,slider.max=max;const currentValue=parseFloat(slider.value);currentValue<min&&(slider.value=min),currentValue>max&&(slider.value=max),this.params[param]=parseFloat(slider.value),valueDisplay.textContent=parseFloat(slider.value).toFixed(2),this.plot()};minInput.addEventListener("change",updateSliderRange),maxInput.addEventListener("change",updateSliderRange),slider.addEventListener("input",()=>{const value=parseFloat(slider.value);this.params[param]=value,valueDisplay.textContent=value.toFixed(2),this.plot()}),valueDisplay.style.cursor="pointer",valueDisplay.addEventListener("click",()=>{const currentValue=this.params[param],newValue=prompt(`Enter new value for ${param}:`,currentValue);if(null!==newValue&&""!==newValue.trim()){const parsedValue=parseFloat(newValue);if(isNaN(parsedValue))alert("Please enter a valid number.");else{let min=parseFloat(slider.min),max=parseFloat(slider.max);parsedValue>max&&(max=parsedValue,maxInput.value=max,slider.max=max),parsedValue<min&&(min=parsedValue,minInput.value=min,slider.min=min),slider.value=parsedValue,this.params[param]=parsedValue,valueDisplay.textContent=parsedValue.toFixed(2),this.plot()}}}),this.params[param]=parseFloat(slider.value),valueDisplay.textContent=parseFloat(slider.value).toFixed(2)})},parseFunction(expr){let processed=expr.replace(/\s+/g,"");processed=processed.replace(/\^/g,"**").replace(/PI/g,"Math.PI").replace(/\be\b/g,"Math.E"),processed=processed.replace(/\barcsin\(/g,"asin("),processed=processed.replace(/\barccos\(/g,"acos("),processed=processed.replace(/\barctan\(/g,"atan(");return["sin","cos","tan","asin","acos","atan","atan2","sinh","cosh","tanh","sqrt","abs","exp","log","pow","floor","ceil","round"].forEach(func=>{const regex=new RegExp(`\\b${func}\\(`,"g");processed=processed.replace(regex,`Math.${func}(`)}),processed},evaluateFunction(expr,x){try{const processed=this.parseFunction(expr),{a:a,b:b,c:c,d:d,q:q}=this.params;return new Function("x","a","b","c","d","q","Math",`'use strict'; return (${processed});`)(x,a,b,c,d,q,Math)}catch(error){return NaN}},analyticalDerivative(expr){try{return expr=expr.trim(),x=>{const h=Math.max(1e-7,1e-6*Math.abs(x)),{a:a,b:b,c:c,d:d,q:q}=this.params;return(this.evaluateFunction(expr,x+h)-this.evaluateFunction(expr,x-h))/(2*h)}}catch(error){return()=>NaN}},getSymbolicDerivative(expr){const polyMatch=(expr=expr.trim()).match(/^([abcdq]?)\*?x\*\*(\d+)$/);if(polyMatch){const coef=polyMatch[1]||"1",power=parseInt(polyMatch[2]);return 1===power?coef:2===power?("1"===coef?"":coef+"*")+"2*x":`${"1"===coef?"":coef+"*"}${power}*x**${power-1}`}const linearMatch=expr.match(/^([abcdq]?)\*?x\s*[\+\-]\s*[abcdq\d\.]+$/);return linearMatch?linearMatch[1]||"1":"x"===expr?"1":expr.includes("x")?expr.match(/^Math\.sin\(x\)$/)?"Math.cos(x)":expr.match(/^Math\.cos\(x\)$/)?"-Math.sin(x)":expr.match(/^Math\.tan\(x\)$/)?"1/(Math.cos(x)**2)":expr.match(/^Math\.exp\(x\)$/)?"Math.exp(x)":expr.match(/^Math\.log\(x\)$/)?"1/x":null:"0"},getSymbolicIntegral(expr){const polyMatch=(expr=expr.trim()).match(/^([abcdq]?)\*?x\*\*(\d+)$/);if(polyMatch){const coef=polyMatch[1]||"1",newPower=parseInt(polyMatch[2])+1;return`${"1"===coef?"":coef+"*"}(x**${newPower})/${newPower}`}if(expr.match(/^([abcdq])\*?x$/)){return`${expr.match(/^([abcdq])/)[1]}*x**2/2`}if("x"===expr)return"x**2/2";const constMatch=expr.match(/^([abcde\d\.]+)$/);return constMatch?`${constMatch[1]}*x`:"1/x"===expr?"Math.log(Math.abs(x))":expr.match(/^Math\.sin\(x\)$/)?"-Math.cos(x)":expr.match(/^Math\.cos\(x\)$/)?"Math.sin(x)":expr.match(/^Math\.exp\(x\)$/)?"Math.exp(x)":null},numericalIntegral(expr,xMin,xMax,numPoints=30){if("trapezoidal"===(document.getElementById("integration-method")?.value||"trapezoidal")){const dx=(xMax-xMin)/numPoints;let sum=0;for(let i=0;i<=numPoints;i++){const x=xMin+i*dx,y=this.evaluateFunction(expr,x);!isNaN(y)&&isFinite(y)&&(sum+=0===i||i===numPoints?y/2:y)}return sum*dx}{const n=numPoints%2==0?numPoints:numPoints+1,h=(xMax-xMin)/n;let sum=this.evaluateFunction(expr,xMin)+this.evaluateFunction(expr,xMax);for(let i=1;i<n;i++){const x=xMin+i*h,y=this.evaluateFunction(expr,x);isFinite(y)&&(sum+=i%2==0?2*y:4*y)}return h/3*sum}},computeIntegralFunction(expr,xArray){const symbolicIntegral=this.getSymbolicIntegral(expr);if(symbolicIntegral){const xMin=xArray[0],integralAtMin=this.evaluateFunction(symbolicIntegral,xMin);return xArray.map(x=>this.evaluateFunction(symbolicIntegral,x)-integralAtMin)}{const integralValues=[],xMin=xArray[0],sampleInterval=Math.max(1,Math.floor(xArray.length/100)),samplePoints=[],sampleIntegrals=[];for(let i=0;i<xArray.length;i+=sampleInterval){const xCurrent=xArray[i],integralValue=this.numericalIntegral(expr,xMin,xCurrent);samplePoints.push(i),sampleIntegrals.push(integralValue)}if(samplePoints[samplePoints.length-1]!==xArray.length-1){const xCurrent=xArray[xArray.length-1],integralValue=this.numericalIntegral(expr,xMin,xCurrent);samplePoints.push(xArray.length-1),sampleIntegrals.push(integralValue)}for(let i=0;i<xArray.length;i++){let lowerIdx=0,upperIdx=0;for(let j=0;j<samplePoints.length-1;j++)if(i>=samplePoints[j]&&i<=samplePoints[j+1]){lowerIdx=j,upperIdx=j+1;break}if(samplePoints.includes(i)){const idx=samplePoints.indexOf(i);integralValues.push(sampleIntegrals[idx])}else{const t=(i-samplePoints[lowerIdx])/(samplePoints[upperIdx]-samplePoints[lowerIdx]),interpolated=sampleIntegrals[lowerIdx]+t*(sampleIntegrals[upperIdx]-sampleIntegrals[lowerIdx]);integralValues.push(interpolated)}}return integralValues}},computeAnalyticalIntegralFunction(integralExpr,xArray){const xMin=xArray[0],integralAtMin=this.evaluateFunction(integralExpr,xMin);return xArray.map(x=>this.evaluateFunction(integralExpr,x)-integralAtMin)},computeDerivativeFunction(expr,xArray){const symbolicDerivative=this.getSymbolicDerivative(expr);if(symbolicDerivative)return xArray.map(x=>this.evaluateFunction(symbolicDerivative,x));{const h=(xArray[xArray.length-1]-xArray[0])/(xArray.length-1);return xArray.map((x,i)=>{if(0===i){const f0=this.evaluateFunction(expr,xArray[i]);return(this.evaluateFunction(expr,xArray[i+1])-f0)/h}if(i===xArray.length-1){const f0=this.evaluateFunction(expr,xArray[i-1]);return(this.evaluateFunction(expr,xArray[i])-f0)/h}{const f0=this.evaluateFunction(expr,xArray[i-1]);return(this.evaluateFunction(expr,xArray[i+1])-f0)/(2*h)}})}},plot(){const xMin=parseFloat(document.getElementById("x-min").value),xMax=parseFloat(document.getElementById("x-max").value),yMin=parseFloat(document.getElementById("y-min").value),yMax=parseFloat(document.getElementById("y-max").value),autoScaleY=document.getElementById("auto-scale-y").checked,numPoints=parseInt(document.getElementById("plot-points").value)||200,computeIntegrals=document.getElementById("compute-integrals").checked,funcF=document.getElementById("func-f").value.trim(),funcG=document.getElementById("func-g").value.trim(),funcH=document.getElementById("func-h").value.trim(),funcU=document.getElementById("func-u").value.trim(),funcFDeriv=document.getElementById("func-f-deriv").value.trim(),funcGDeriv=document.getElementById("func-g-deriv").value.trim(),funcHDeriv=document.getElementById("func-h-deriv").value.trim(),funcUDeriv=document.getElementById("func-u-deriv").value.trim(),funcFInteg=document.getElementById("func-f-integ").value.trim(),funcGInteg=document.getElementById("func-g-integ").value.trim(),funcHInteg=document.getElementById("func-h-integ").value.trim(),funcUInteg=document.getElementById("func-u-integ").value.trim(),xValues=[],dx=(xMax-xMin)/(numPoints-1);for(let i=0;i<numPoints;i++)xValues.push(xMin+i*dx);const fValues=funcF?xValues.map(x=>this.evaluateFunction(funcF,x)):[],gValues=funcG?xValues.map(x=>this.evaluateFunction(funcG,x)):[],hValues=funcH?xValues.map(x=>this.evaluateFunction(funcH,x)):[],uValues=funcU?xValues.map(x=>this.evaluateFunction(funcU,x)):[],fDerivValues=funcF?funcFDeriv?xValues.map(x=>this.evaluateFunction(funcFDeriv,x)):this.computeDerivativeFunction(funcF,xValues):[],gDerivValues=funcG?funcGDeriv?xValues.map(x=>this.evaluateFunction(funcGDeriv,x)):this.computeDerivativeFunction(funcG,xValues):[],hDerivValues=funcH?funcHDeriv?xValues.map(x=>this.evaluateFunction(funcHDeriv,x)):this.computeDerivativeFunction(funcH,xValues):[],uDerivValues=funcU?funcUDeriv?xValues.map(x=>this.evaluateFunction(funcUDeriv,x)):this.computeDerivativeFunction(funcU,xValues):[];let FValues=[],GValues=[],HValues=[],UValues=[];computeIntegrals&&(FValues=funcF?funcFInteg?this.computeAnalyticalIntegralFunction(funcFInteg,xValues):this.computeIntegralFunction(funcF,xValues):[],GValues=funcG?funcGInteg?this.computeAnalyticalIntegralFunction(funcGInteg,xValues):this.computeIntegralFunction(funcG,xValues):[],HValues=funcH?funcHInteg?this.computeAnalyticalIntegralFunction(funcHInteg,xValues):this.computeIntegralFunction(funcH,xValues):[],UValues=funcU?funcUInteg?this.computeAnalyticalIntegralFunction(funcUInteg,xValues):this.computeIntegralFunction(funcU,xValues):[]);let mainYMin=yMin,mainYMax=yMax,integralYMin=yMin,integralYMax=yMax,derivativeYMin=yMin,derivativeYMax=yMax;if(autoScaleY){const allMainValues=[...fValues,...gValues,...hValues,...uValues].filter(isFinite);if(allMainValues.length>0){mainYMin=Math.min(...allMainValues),mainYMax=Math.max(...allMainValues);const mainMargin=.1*(mainYMax-mainYMin);mainYMin-=mainMargin,mainYMax+=mainMargin}if(computeIntegrals){const allIntegralValues=[...FValues,...GValues,...HValues,...UValues].filter(isFinite);if(allIntegralValues.length>0){integralYMin=Math.min(...allIntegralValues),integralYMax=Math.max(...allIntegralValues);const integralMargin=.1*(integralYMax-integralYMin);integralYMin-=integralMargin,integralYMax+=integralMargin}}const allDerivValues=[...fDerivValues,...gDerivValues,...hDerivValues,...uDerivValues].filter(isFinite);if(allDerivValues.length>0){derivativeYMin=Math.min(...allDerivValues),derivativeYMax=Math.max(...allDerivValues);const derivMargin=.1*(derivativeYMax-derivativeYMin);derivativeYMin-=derivMargin,derivativeYMax+=derivMargin}}const mainDatasets=[{data:fValues,color:"#2ecc71",label:"f(x)",active:funcF},{data:gValues,color:"#f39c12",label:"g(x)",active:funcG},{data:hValues,color:"#3498db",label:"h(x)",active:funcH},{data:uValues,color:"#e73c3c",label:"u(x)",active:funcU}].filter(ds=>ds.active);if(this.plotCanvas(this.ctxMain,this.canvasMain,xValues,mainDatasets,xMin,xMax,mainYMin,mainYMax),computeIntegrals){const integralDatasets=[{data:FValues,color:"#2ecc71",label:"F(x) = ∫f",active:funcF},{data:GValues,color:"#f39c12",label:"G(x) = ∫g",active:funcG},{data:HValues,color:"#3498db",label:"H(x) = ∫h",active:funcH},{data:UValues,color:"#e73c3c",label:"U(x) = ∫u",active:funcU}].filter(ds=>ds.active);this.plotCanvas(this.ctxIntegral,this.canvasIntegral,xValues,integralDatasets,xMin,xMax,integralYMin,integralYMax)}else{this.ctxIntegral.clearRect(0,0,this.canvasIntegral.width,this.canvasIntegral.height);const isDarkMode=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches;this.ctxIntegral.fillStyle=isDarkMode?"#FFFFFF":"#000000",this.ctxIntegral.font="30px HaraldMono, monospace",this.ctxIntegral.textAlign="center",this.ctxIntegral.textBaseline="middle",this.ctxIntegral.fillText("Integrals disabled",this.canvasIntegral.width/2,this.canvasIntegral.height/2),this.ctxIntegral.font="30px HaraldMono, monospace",this.ctxIntegral.fillText("(enable in settings)",this.canvasIntegral.width/2,this.canvasIntegral.height/2+25)}const derivativeDatasets=[{data:fDerivValues,color:"#2ecc71",label:"f'(x)",active:funcF},{data:gDerivValues,color:"#f39c12",label:"g'(x)",active:funcG},{data:hDerivValues,color:"#3498db",label:"h'(x)",active:funcH},{data:uDerivValues,color:"#e73c3c",label:"u'(x)",active:funcU}].filter(ds=>ds.active);this.plotCanvas(this.ctxDerivative,this.canvasDerivative,xValues,derivativeDatasets,xMin,xMax,derivativeYMin,derivativeYMax)},plotCanvas(ctx,canvas,xValues,dataSets,xMin,xMax,yMin,yMax){const width=canvas.width,height=canvas.height,plotWidth=width-120,plotHeight=height-120;ctx.clearRect(0,0,width,height);const isDarkMode=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,textColor=isDarkMode?"#FFFFFF":"#000000",gridColor=isDarkMode?"rgba(255, 255, 255, 0.15)":"rgba(0, 0, 0, 0.15)",axisColor=isDarkMode?"rgba(255, 255, 255, 0.4)":"rgba(0, 0, 0, 0.4)",xToCanvas=x=>60+(x-xMin)/(xMax-xMin)*plotWidth,yToCanvas=y=>height-60-(y-yMin)/(yMax-yMin)*plotHeight;ctx.strokeStyle=gridColor,ctx.lineWidth=1;const xStep=this.calculateNiceStep(xMin,xMax,10);for(let x=Math.ceil(xMin/xStep)*xStep;x<=xMax;x+=xStep){const canvasX=xToCanvas(x);ctx.beginPath(),ctx.moveTo(canvasX,60),ctx.lineTo(canvasX,height-60),ctx.stroke()}const yStep=this.calculateNiceStep(yMin,yMax,8);for(let y=Math.ceil(yMin/yStep)*yStep;y<=yMax;y+=yStep){const canvasY=yToCanvas(y);ctx.beginPath(),ctx.moveTo(60,canvasY),ctx.lineTo(width-60,canvasY),ctx.stroke()}if(ctx.strokeStyle=axisColor,ctx.lineWidth=2,yMin<=0&&yMax>=0){const y0=yToCanvas(0);ctx.beginPath(),ctx.moveTo(60,y0),ctx.lineTo(width-60,y0),ctx.stroke()}if(xMin<=0&&xMax>=0){const x0=xToCanvas(0);ctx.beginPath(),ctx.moveTo(x0,60),ctx.lineTo(x0,height-60),ctx.stroke()}ctx.fillStyle=textColor,ctx.font="28px HaraldMono, monospace",ctx.textAlign="center",ctx.textBaseline="top";for(let x=Math.ceil(xMin/xStep)*xStep;x<=xMax;x+=xStep){const canvasX=xToCanvas(x);ctx.fillText(x.toFixed(1),canvasX,height-60+10)}ctx.textAlign="right",ctx.textBaseline="middle";for(let y=Math.ceil(yMin/yStep)*yStep;y<=yMax;y+=yStep){const canvasY=yToCanvas(y);ctx.fillText(y.toFixed(1),50,canvasY)}dataSets.forEach(({data:data,color:color,label:label})=>{ctx.strokeStyle=color,ctx.lineWidth=2.5,ctx.beginPath();let firstPoint=!0;for(let i=0;i<xValues.length;i++){const x=xValues[i],y=data[i];if(!isFinite(y)){firstPoint=!0;continue}const canvasX=xToCanvas(x),canvasY=yToCanvas(y);firstPoint?(ctx.moveTo(canvasX,canvasY),firstPoint=!1):ctx.lineTo(canvasX,canvasY)}ctx.stroke()});const canvasType=canvas===this.canvasMain?"main":canvas===this.canvasIntegral?"integral":"derivative",clickedPoint=this.clickedPoints[canvasType];if(clickedPoint){const plotX=xMin+(clickedPoint.x-60)/plotWidth*(xMax-xMin),plotY=yMax-(clickedPoint.y-60)/plotHeight*(yMax-yMin),coordText=`(${plotX.toFixed(2)}, ${plotY.toFixed(2)})`;ctx.font="24px HaraldMono, monospace",ctx.textAlign="center",ctx.textBaseline="bottom";const textWidth=ctx.measureText(coordText).width,textHeight=24,bgPadding=5;ctx.fillStyle=isDarkMode?"rgba(0, 0, 0, 0.7)":"rgba(255, 255, 255, 0.9)",ctx.fillRect(clickedPoint.x-textWidth/2-bgPadding,clickedPoint.y-textHeight-bgPadding-10,textWidth+2*bgPadding,textHeight+2*bgPadding),ctx.strokeStyle=isDarkMode?"rgba(255, 255, 255, 0.5)":"rgba(0, 0, 0, 0.3)",ctx.lineWidth=1,ctx.strokeRect(clickedPoint.x-textWidth/2-bgPadding,clickedPoint.y-textHeight-bgPadding-10,textWidth+2*bgPadding,textHeight+2*bgPadding),ctx.fillStyle=textColor,ctx.fillText(coordText,clickedPoint.x,clickedPoint.y-10),ctx.fillStyle=isDarkMode?"#FFFFFF":"#000000",ctx.beginPath(),ctx.arc(clickedPoint.x,clickedPoint.y,4,0,2*Math.PI),ctx.fill()}const legendX=width-60-10;ctx.textAlign="right",ctx.textBaseline="middle",ctx.font="28px HaraldMono, monospace",dataSets.forEach(({color:color,label:label},index)=>{const y=70+25*index;ctx.strokeStyle=color,ctx.lineWidth=2.5,ctx.beginPath(),ctx.moveTo(legendX-30,y),ctx.lineTo(legendX,y),ctx.stroke(),ctx.fillStyle=textColor,ctx.fillText(label,legendX-30-10,y)})},calculateNiceStep(min,max,targetSteps){const roughStep=(max-min)/targetSteps,magnitude=Math.pow(10,Math.floor(Math.log10(roughStep))),normalizedStep=roughStep/magnitude;let niceStep;return niceStep=normalizedStep<=1?1:normalizedStep<=2?2:normalizedStep<=5?5:10,niceStep*magnitude}};window.addEventListener("DOMContentLoaded",()=>{app.init()});