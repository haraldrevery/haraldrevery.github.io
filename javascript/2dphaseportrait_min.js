const app={canvas:null,ctx:null,canvasXvsT:null,ctxXvsT:null,canvasYvsT:null,ctxYvsT:null,trajectories:[],params:[1,1,1,1,1],integrator:"euler",jacobianPoint:null,init(){this.canvas=document.getElementById("phase-portrait"),this.ctx=this.canvas.getContext("2d"),this.canvasXvsT=document.getElementById("x-vs-t-plot"),this.ctxXvsT=this.canvasXvsT.getContext("2d"),this.canvasYvsT=document.getElementById("y-vs-t-plot"),this.ctxYvsT=this.canvasYvsT.getContext("2d"),this.setupParamSliders(),this.canvas.addEventListener("click",e=>this.handleCanvasClick(e)),document.getElementById("x-dot").addEventListener("input",()=>this.autoClearAnalysis()),document.getElementById("y-dot").addEventListener("input",()=>this.autoClearAnalysis()),this.plot()},setIntegrator(method){this.integrator=method,document.getElementById("euler-btn").classList.toggle("active","euler"===method),document.getElementById("rk4-btn").classList.toggle("active","rk4"===method)},loadPreset(name){const presets={"limit-cycle":{xDot:"-a*y - b*x*(x^2 + y^2 - 1)",yDot:"a*x - b*y*(x^2 + y^2 - 1)"},saddle:{xDot:"a*x",yDot:"-b*y"},spiral:{xDot:"-a*x - b*y",yDot:"b*x - a*y"},pendulum:{xDot:"a*y",yDot:"-sin(c*x) - 0.1*y/b"}};presets[name]&&(document.getElementById("x-dot").value=presets[name].xDot,document.getElementById("y-dot").value=presets[name].yDot,this.plot())},calculateStability(){const a=parseFloat(document.getElementById("jac-a").value)||0,b=parseFloat(document.getElementById("jac-b").value)||0,c=parseFloat(document.getElementById("jac-c").value)||0,d=parseFloat(document.getElementById("jac-d").value)||0,resultDiv=document.getElementById("stability-results"),trace=a+d,det=a*d-b*c,discriminant=trace*trace-4*det;let html=`<strong>Matrix:</strong> [${a}, ${b}; ${c}, ${d}]<br>`;if(html+=`<strong>Trace (τ):</strong> ${trace.toFixed(4)}<br>`,html+=`<strong>Determinant (Δ):</strong> ${det.toFixed(4)}<br>`,html+=`<strong>Discriminant:</strong> ${discriminant.toFixed(4)}<br><br>`,discriminant>=0){const lambda1=(trace+Math.sqrt(discriminant))/2,lambda2=(trace-Math.sqrt(discriminant))/2;html+="<strong>Eigenvalues:</strong><br>",html+=`λ₁ = ${lambda1.toFixed(4)}<br>`,html+=`λ₂ = ${lambda2.toFixed(4)}<br><br>`;const calculateEigenvector=lambda=>{const m11=a-lambda,m12=b,m21=c,m22=d-lambda;return Math.abs(m11)>1e-10||Math.abs(m12)>1e-10?Math.abs(m12)>1e-10?[-m12,m11]:[0,1]:Math.abs(m21)>1e-10||Math.abs(m22)>1e-10?Math.abs(m22)>1e-10?[m22,-m21]:[0,1]:[1,0]},v1=calculateEigenvector(lambda1),v2=calculateEigenvector(lambda2),norm1=Math.sqrt(v1[0]*v1[0]+v1[1]*v1[1]),norm2=Math.sqrt(v2[0]*v2[0]+v2[1]*v2[1]);html+="<strong>Eigenvectors:</strong><br>",html+=`v₁ = [${(v1[0]/norm1).toFixed(4)}, ${(v1[1]/norm1).toFixed(4)}]<br>`,html+=`v₂ = [${(v2[0]/norm2).toFixed(4)}, ${(v2[1]/norm2).toFixed(4)}]<br><br>`}else{const realPart=trace/2,imagPart=Math.sqrt(-discriminant)/2;if(html+="<strong>Eigenvalues (Complex):</strong><br>",html+=`λ₁ = ${realPart.toFixed(4)} + ${imagPart.toFixed(4)}i<br>`,html+=`λ₂ = ${realPart.toFixed(4)} - ${imagPart.toFixed(4)}i<br><br>`,Math.abs(b)>1e-10){const v2_real=realPart-a,v2_imag=imagPart;html+="<strong>Complex Eigenvector (v₁):</strong><br>",html+=`v₁ = [${b.toFixed(4)}, ${v2_real.toFixed(4)} + ${v2_imag.toFixed(4)}i]<br>`,html+="<small>(Rotation axis determined by real/imag parts)</small><br><br>"}}html+="<strong>Classification:</strong> ",html+=det<0?"Saddle Point (unstable)":det>0?discriminant>0?trace<0?"Stable Node":trace>0?"Unstable Node":"Linear Center (non-hyperbolic - check higher-order terms)":trace<0?"Stable Spiral":trace>0?"Unstable Spiral":"Linear Center (non-hyperbolic - check higher-order terms)":"Non-isolated fixed points",resultDiv.innerHTML=html,resultDiv.style.display="block"},calculateJacobianAtPoint(x,y){const xDotExpr=document.getElementById("x-dot").value,yDotExpr=document.getElementById("y-dot").value;if(!xDotExpr||!yDotExpr)return void alert("Please enter both differential equations first");const vectorField=this.createVectorField(xDotExpr,yDotExpr),precision=parseInt(document.getElementById("jacobian-precision").value)||3,h=1e-6,[f_x,g_x]=vectorField(x,y),[f_xph,g_xph]=vectorField(x+h,y),[f_xmh,g_xmh]=vectorField(x-h,y),[f_yph,g_yph]=vectorField(x,y+h),[f_ymh,g_ymh]=vectorField(x,y-h),df_dx=(f_xph-f_xmh)/(2*h),df_dy=(f_yph-f_ymh)/(2*h),dg_dx=(g_xph-g_xmh)/(2*h),dg_dy=(g_yph-g_ymh)/(2*h);if(!(isFinite(df_dx)&&isFinite(df_dy)&&isFinite(dg_dx)&&isFinite(dg_dy)))return void alert("Could not compute Jacobian at this point (possible singularity or numerical overflow).");const J=[[df_dx,df_dy],[dg_dx,dg_dy]];this.jacobianPoint={x:x,y:y};const trace=J[0][0]+J[1][1],det=J[0][0]*J[1][1]-J[0][1]*J[1][0],discriminant=trace*trace-4*det;this.displayJacobianAnalysis(x,y,J,trace,det,discriminant,precision),this.calculateIndex(x,y,vectorField,precision),this.plot()},displayJacobianAnalysis(x,y,J,trace,det,discriminant,precision){const content=document.getElementById("jacobian-content"),display=document.getElementById("jacobian-display");let html=`<strong>Point:</strong> (${x.toFixed(precision)}, ${y.toFixed(precision)})<br><br>`;if(html+="<strong>Jacobian Matrix:</strong><br>",html+=`J = [${J[0][0].toFixed(precision)}, ${J[0][1].toFixed(precision)}]<br>`,html+=`    [${J[1][0].toFixed(precision)}, ${J[1][1].toFixed(precision)}]<br><br>`,html+=`<strong>Trace (τ):</strong> ${trace.toFixed(precision)}<br>`,html+=`<strong>Determinant (Δ):</strong> ${det.toFixed(precision)}<br>`,html+=`<strong>Discriminant:</strong> ${discriminant.toFixed(precision)}<br><br>`,discriminant>=0){const lambda1=(trace+Math.sqrt(discriminant))/2,lambda2=(trace-Math.sqrt(discriminant))/2;html+="<strong>Eigenvalues (Real):</strong><br>",html+=`λ₁ = ${lambda1.toFixed(precision)}<br>`,html+=`λ₂ = ${lambda2.toFixed(precision)}<br><br>`}else{const realPart=trace/2,imagPart=Math.sqrt(-discriminant)/2;html+="<strong>Eigenvalues (Complex):</strong><br>",html+=`λ₁ = ${realPart.toFixed(precision)} + ${imagPart.toFixed(precision)}i<br>`,html+=`λ₂ = ${realPart.toFixed(precision)} - ${imagPart.toFixed(precision)}i<br><br>`}html+="<strong>Classification:</strong> ",Math.abs(det)<1e-6?html+="Degenerate (det ≈ 0)":det<0?html+="Saddle Point (unstable)":det>0&&(html+=discriminant>0?trace<0?"Stable Node":trace>0?"Unstable Node":"Linear Center (non-hyperbolic - check higher-order terms)":trace<0?"Stable Spiral":trace>0?"Unstable Spiral":"Linear Center (non-hyperbolic - check higher-order terms)"),content.innerHTML=html,display.style.display="block"},clearJacobianAnalysis(){this.jacobianPoint=null,document.getElementById("jacobian-display").style.display="none",document.getElementById("index-content").style.display="none",document.getElementById("index-recalc-button").style.display="none",this.plot()},calculateIndex(x,y,vectorField,precision){const radius=parseFloat(document.getElementById("index-radius").value)||.2,angles=[];for(let i=0;i<1e3;i++)angles.push(2*Math.PI*i/1e3);const vectorAngles=[];for(let i=0;i<1e3;i++){const sampleX=x+radius*Math.cos(angles[i]),sampleY=y+radius*Math.sin(angles[i]),[vx,vy]=vectorField(sampleX,sampleY),angle=Math.atan2(vy,vx);vectorAngles.push(angle)}const unwrappedAngles=[vectorAngles[0]];for(let i=1;i<vectorAngles.length;i++){let diff=vectorAngles[i]-vectorAngles[i-1];for(;diff>Math.PI;)diff-=2*Math.PI;for(;diff<-Math.PI;)diff+=2*Math.PI;unwrappedAngles.push(unwrappedAngles[i-1]+diff)}const totalRotation=(unwrappedAngles[unwrappedAngles.length-1]-unwrappedAngles[0])/(2*Math.PI),index=Math.round(totalRotation);this.displayIndex(x,y,radius,totalRotation,index,precision)},displayIndex(x,y,radius,totalRotation,index,precision){const indexContent=document.getElementById("index-content");let html="<strong>Index Theory (Poincaré Index):</strong><br><br>";html+="<strong>Integration Circle:</strong><br>",html+=`Center: (${x.toFixed(precision)}, ${y.toFixed(precision)})<br>`,html+=`Radius: ${radius.toFixed(precision)}<br><br>`,html+=`<strong>Total Rotation:</strong> ${totalRotation.toFixed(precision)} revolutions<br>`,html+=`<strong>Index:</strong> ${index}<br><br>`,html+="<strong>Interpretation:</strong><br>",Math.abs(index)<.1?html+="No fixed point inside the circle (index ≈ 0)<br>":html+=1===index?"Typical fixed point: source, sink, or spiral (index = +1)<br>":-1===index?"Saddle point (index = -1)<br>":`Complex behavior with index = ${index}<br>`,indexContent.innerHTML=html,indexContent.style.display="block",document.getElementById("index-recalc-button").style.display="block"},recalculateIndex(){if(!this.jacobianPoint)return void alert("No point selected. Please click on the phase portrait first.");const xDotExpr=document.getElementById("x-dot").value,yDotExpr=document.getElementById("y-dot").value;if(!xDotExpr||!yDotExpr)return void alert("Please enter both differential equations first");const vectorField=this.createVectorField(xDotExpr,yDotExpr),precision=parseInt(document.getElementById("jacobian-precision").value)||3;this.calculateIndex(this.jacobianPoint.x,this.jacobianPoint.y,vectorField,precision)},autoClearAnalysis(){null!==this.jacobianPoint&&(this.jacobianPoint=null,document.getElementById("jacobian-display").style.display="none",document.getElementById("index-content").style.display="none",document.getElementById("index-recalc-button").style.display="none")},setupParamSliders(){for(let i=0;i<5;i++){const minInput=document.getElementById(`param-min-${i}`),maxInput=document.getElementById(`param-max-${i}`),slider=document.getElementById(`param-slider-${i}`),valueDisplay=document.getElementById(`param-value-${i}`);if(!(minInput&&maxInput&&slider&&valueDisplay))continue;this.params[i]=parseFloat(slider.value)||1,valueDisplay.textContent=this.params[i].toFixed(2),valueDisplay.style.pointerEvents="auto",valueDisplay.style.cursor="pointer",valueDisplay.title="Click to enter custom value",valueDisplay.addEventListener("click",e=>{e.stopPropagation();const inputField=document.createElement("input");inputField.type="number",inputField.step="any",inputField.value=this.params[i],inputField.style.cssText="\n                position: absolute;\n                top: -24px;\n                left: 50%;\n                transform: translateX(-50%);\n                width: 80px;\n                padding: 2px 4px;\n                font-family: var(--font-mono);\n                font-size: 0.75rem;\n                font-weight: 600;\n                text-align: center;\n                border: 1px solid #ccc;\n                border-radius: 4px;\n                background: white;\n                color: black;\n                z-index: 100;\n                box-shadow: 0 2px 5px rgba(0,0,0,0.2);\n            ",window.matchMedia("(prefers-color-scheme: dark)").matches&&(inputField.style.background="#333",inputField.style.color="#fff",inputField.style.border="1px solid #666"),valueDisplay.style.visibility="hidden",valueDisplay.parentElement.appendChild(inputField),inputField.focus(),inputField.select();const commitChange=()=>{let val=parseFloat(inputField.value);if(Number.isFinite(val)){let currentMin=parseFloat(minInput.value),currentMax=parseFloat(maxInput.value);val<currentMin&&(currentMin=val,minInput.value=val,slider.min=val),val>currentMax&&(currentMax=val,maxInput.value=val,slider.max=val),slider.step=(currentMax-currentMin)/200,this.params[i]=val,slider.value=val,valueDisplay.textContent=val.toFixed(2)}inputField.parentElement&&inputField.remove(),valueDisplay.style.visibility="visible",this.plot(),this.autoClearAnalysis()};inputField.addEventListener("keydown",e=>{"Enter"===e.key?commitChange():"Escape"===e.key&&(inputField.remove(),valueDisplay.style.visibility="visible")}),inputField.addEventListener("blur",()=>{commitChange()})});const updateSliderRange=()=>{let min=parseFloat(minInput.value),max=parseFloat(maxInput.value);isNaN(min)&&(min=-10),isNaN(max)&&(max=10),min>=max&&(max=min+1,maxInput.value=max),slider.min=min,slider.max=max,slider.step=(max-min)/200;let current=this.params[i];current<min&&(current=min),current>max&&(current=max),this.params[i]=current,slider.value=current,valueDisplay.textContent=current.toFixed(2),this.plot(),this.autoClearAnalysis()};minInput.addEventListener("change",updateSliderRange),maxInput.addEventListener("change",updateSliderRange),slider.addEventListener("input",e=>{const val=parseFloat(e.target.value);this.params[i]=val,valueDisplay.textContent=val.toFixed(2),this.plot(),this.autoClearAnalysis()})}},createVectorField(xDotExpr,yDotExpr){const[a,b,c,d,q]=this.params,safeXExpr=xDotExpr.replace(/\^/g,"**"),safeYExpr=yDotExpr.replace(/\^/g,"**");try{const xFunc=new Function("x","y","a","b","c","d","q","sin","cos","tan","exp","log","sqrt","abs","arcsin","arccos","arctan","arctan2","sinh","cosh","tanh","pow","PI","e",`\n                    "use strict";\n                    return ${safeXExpr};\n                `),yFunc=new Function("x","y","a","b","c","d","q","sin","cos","tan","exp","log","sqrt","abs","arcsin","arccos","arctan","arctan2","sinh","cosh","tanh","pow","PI","e",`\n                    "use strict";\n                    return ${safeYExpr};\n                `);return(x,y)=>{try{const dx=xFunc(x,y,a,b,c,d,q,Math.sin,Math.cos,Math.tan,Math.exp,Math.log,Math.sqrt,Math.abs,Math.asin,Math.acos,Math.atan,Math.atan2,Math.sinh,Math.cosh,Math.tanh,Math.pow,Math.PI,Math.E);return[dx,yFunc(x,y,a,b,c,d,q,Math.sin,Math.cos,Math.tan,Math.exp,Math.log,Math.sqrt,Math.abs,Math.asin,Math.acos,Math.atan,Math.atan2,Math.sinh,Math.cosh,Math.tanh,Math.pow,Math.PI,Math.E)]}catch(e){return[0,0]}}}catch(e){return console.error("Error creating vector field:",e),()=>[0,0]}},handleCanvasClick(event){const rect=this.canvas.getBoundingClientRect(),scaleX=this.canvas.width/rect.width,scaleY=this.canvas.height/rect.height,canvasX=(event.clientX-rect.left)*scaleX,canvasY=(event.clientY-rect.top)*scaleY,[worldX,worldY]=this.canvasToWorld(canvasX,canvasY);document.getElementById("traj-x").value=worldX.toFixed(2),document.getElementById("traj-y").value=worldY.toFixed(2),this.calculateJacobianAtPoint(worldX,worldY)},worldToCanvas(x,y){const xMin=parseFloat(document.getElementById("x-min").value),xMax=parseFloat(document.getElementById("x-max").value),yMin=parseFloat(document.getElementById("y-min").value),yMax=parseFloat(document.getElementById("y-max").value);return[(x-xMin)/(xMax-xMin)*this.canvas.width,(yMax-y)/(yMax-yMin)*this.canvas.height]},canvasToWorld(canvasX,canvasY){const xMin=parseFloat(document.getElementById("x-min").value),xMax=parseFloat(document.getElementById("x-max").value),yMin=parseFloat(document.getElementById("y-min").value),yMax=parseFloat(document.getElementById("y-max").value);return[xMin+canvasX/this.canvas.width*(xMax-xMin),yMax-canvasY/this.canvas.height*(yMax-yMin)]},drawArrow(x,y,dx,dy,color,scale=1){const mag=Math.sqrt(dx*dx+dy*dy);if(0===mag||!isFinite(mag))return;const nx=dx/mag,ny=dy/mag,arrowLength=15*scale,headLength=5*scale,[cx,cy]=this.worldToCanvas(x,y),[ex,ey]=[cx+nx*arrowLength,cy-ny*arrowLength];this.ctx.strokeStyle=color,this.ctx.fillStyle=color,this.ctx.lineWidth=1.5,this.ctx.beginPath(),this.ctx.moveTo(cx,cy),this.ctx.lineTo(ex,ey),this.ctx.stroke();const angle=Math.atan2(-ny,nx);this.ctx.beginPath(),this.ctx.moveTo(ex,ey),this.ctx.lineTo(ex-headLength*Math.cos(angle-Math.PI/6),ey+headLength*Math.sin(angle-Math.PI/6)),this.ctx.lineTo(ex-headLength*Math.cos(angle+Math.PI/6),ey+headLength*Math.sin(angle+Math.PI/6)),this.ctx.closePath(),this.ctx.fill()},calculateTrajectorySteps(tMax){let steps=Math.ceil(100*tMax);return Math.max(200,Math.min(steps,1e4))},computeTrajectory(vectorField,x0,y0,tMax,steps){return"rk4"===this.integrator?this.computeTrajectoryRK4(vectorField,x0,y0,tMax,steps):this.computeTrajectoryEuler(vectorField,x0,y0,tMax,steps)},computeTrajectoryEuler(vectorField,x0,y0,tMax,steps){const dt=tMax/steps,trajectory=[[x0,y0]];let x=x0,y=y0;for(let i=0;i<steps;i++){const[dx,dy]=vectorField(x,y);if(!isFinite(dx)||!isFinite(dy))break;x+=dx*dt,y+=dy*dt,trajectory.push([x,y])}return trajectory},computeTrajectoryRK4(vectorField,x0,y0,tMax,steps){const dt=tMax/steps,trajectory=[[x0,y0]];let x=x0,y=y0;for(let i=0;i<steps;i++){const[k1x,k1y]=vectorField(x,y);if(!isFinite(k1x)||!isFinite(k1y))break;const[k2x,k2y]=vectorField(x+.5*k1x*dt,y+.5*k1y*dt);if(!isFinite(k2x)||!isFinite(k2y))break;const[k3x,k3y]=vectorField(x+.5*k2x*dt,y+.5*k2y*dt);if(!isFinite(k3x)||!isFinite(k3y))break;const[k4x,k4y]=vectorField(x+k3x*dt,y+k3y*dt);if(!isFinite(k4x)||!isFinite(k4y))break;x+=dt/6*(k1x+2*k2x+2*k3x+k4x),y+=dt/6*(k1y+2*k2y+2*k3y+k4y),trajectory.push([x,y])}return trajectory},drawGrid(){const xMin=parseFloat(document.getElementById("x-min").value),xMax=parseFloat(document.getElementById("x-max").value),yMin=parseFloat(document.getElementById("y-min").value),yMax=parseFloat(document.getElementById("y-max").value),isDark=window.matchMedia("(prefers-color-scheme: dark)").matches,textColor=isDark?"#e0e0e0":"#333",gridColor=isDark?"rgba(255, 255, 255, 0.15)":"rgba(0, 0, 0, 0.15)",axisColor=isDark?"#888":"#333";this.ctx.strokeStyle=gridColor,this.ctx.lineWidth=1;const xStep=(xMax-xMin)/10;for(let x=Math.ceil(xMin/xStep)*xStep;x<=xMax;x+=xStep){const[cx,cy1]=this.worldToCanvas(x,yMin),[_,cy2]=this.worldToCanvas(x,yMax);this.ctx.beginPath(),this.ctx.moveTo(cx,cy1),this.ctx.lineTo(cx,cy2),this.ctx.stroke()}const yStep=(yMax-yMin)/10;for(let y=Math.ceil(yMin/yStep)*yStep;y<=yMax;y+=yStep){const[cx1,cy]=this.worldToCanvas(xMin,y),[cx2,_]=this.worldToCanvas(xMax,y);this.ctx.beginPath(),this.ctx.moveTo(cx1,cy),this.ctx.lineTo(cx2,cy),this.ctx.stroke()}if(this.ctx.strokeStyle=axisColor,this.ctx.lineWidth=2,yMin<=0&&yMax>=0){const[cx1,cy]=this.worldToCanvas(xMin,0),[cx2,_]=this.worldToCanvas(xMax,0);this.ctx.beginPath(),this.ctx.moveTo(cx1,cy),this.ctx.lineTo(cx2,cy),this.ctx.stroke()}if(xMin<=0&&xMax>=0){const[cx,cy1]=this.worldToCanvas(0,yMin),[_,cy2]=this.worldToCanvas(0,yMax);this.ctx.beginPath(),this.ctx.moveTo(cx,cy1),this.ctx.lineTo(cx,cy2),this.ctx.stroke()}this.ctx.fillStyle=textColor,this.ctx.font="12px monospace",this.ctx.textAlign="center",this.ctx.textBaseline="top";for(let x=Math.ceil(xMin/xStep)*xStep;x<=xMax;x+=xStep){if(Math.abs(x)<xStep/10)continue;const[cx,cy]=this.worldToCanvas(x,0),yOffset=yMin<=0&&yMax>=0?cy+5:this.canvas.height-20;this.ctx.fillText(x.toFixed(1),cx,yOffset)}this.ctx.textAlign="right",this.ctx.textBaseline="middle";for(let y=Math.ceil(yMin/yStep)*yStep;y<=yMax;y+=yStep){if(Math.abs(y)<yStep/10)continue;const[cx,cy]=this.worldToCanvas(0,y),xOffset=xMin<=0&&xMax>=0?cx-10:10;this.ctx.fillText(y.toFixed(1),xOffset,cy)}this.ctx.font="bold 14px monospace",this.ctx.textAlign="center",this.ctx.textBaseline="top";const[xLabelX,xLabelY]=this.worldToCanvas(xMax-.05*(xMax-xMin),0),yOffsetLabel=yMin<=0&&yMax>=0?xLabelY+25:this.canvas.height-10;this.ctx.fillText("x",xLabelX,yOffsetLabel),this.ctx.textAlign="left",this.ctx.textBaseline="middle";const[yLabelX,yLabelY]=this.worldToCanvas(0,yMax-.05*(yMax-yMin)),xOffsetLabel=xMin<=0&&xMax>=0?yLabelX+10:20;this.ctx.fillText("y",xOffsetLabel,yLabelY)},drawLegend(){const isDark=window.matchMedia("(prefers-color-scheme: dark)").matches,textColor=isDark?"#e0e0e0":"#333",bgColor=isDark?"rgba(26, 26, 26, 0.85)":"rgba(255, 255, 255, 0.85)",xNullclineColor=isDark?"#ff6b6b":"#e74c3c",yNullclineColor=isDark?"#4ecdc4":"#3498db",legendX=this.canvas.width-15-150;this.ctx.fillStyle=bgColor,this.ctx.fillRect(legendX-10,15,160,65),this.ctx.strokeStyle=isDark?"rgba(255, 255, 255, 0.2)":"rgba(0, 0, 0, 0.2)",this.ctx.lineWidth=1,this.ctx.strokeRect(legendX-10,15,160,65),this.ctx.globalAlpha=.4,this.ctx.strokeStyle=xNullclineColor,this.ctx.lineWidth=2,this.ctx.setLineDash([5,5]),this.ctx.beginPath(),this.ctx.moveTo(legendX,25),this.ctx.lineTo(legendX+40,25),this.ctx.stroke(),this.ctx.setLineDash([]),this.ctx.globalAlpha=1,this.ctx.fillStyle=textColor,this.ctx.font="13px monospace",this.ctx.textAlign="left",this.ctx.textBaseline="middle",this.ctx.fillText("dx/dt = 0",legendX+40+10,25),this.ctx.globalAlpha=.4,this.ctx.strokeStyle=yNullclineColor,this.ctx.lineWidth=2,this.ctx.setLineDash([5,5]),this.ctx.beginPath(),this.ctx.moveTo(legendX,50),this.ctx.lineTo(legendX+40,50),this.ctx.stroke(),this.ctx.setLineDash([]),this.ctx.globalAlpha=1,this.ctx.fillStyle=textColor,this.ctx.fillText("dy/dt = 0",legendX+40+10,50)},plotNullclines(vectorField){const xMin=parseFloat(document.getElementById("x-min").value),xMax=parseFloat(document.getElementById("x-max").value),yMin=parseFloat(document.getElementById("y-min").value),yMax=parseFloat(document.getElementById("y-max").value),isDark=window.matchMedia("(prefers-color-scheme: dark)").matches,xNullclineColor=isDark?"#ff6b6b":"#e74c3c",yNullclineColor=isDark?"#4ecdc4":"#3498db",xStep=(xMax-xMin)/100,yStep=(yMax-yMin)/100,xDotGrid=[],yDotGrid=[];for(let i=0;i<=100;i++){xDotGrid[i]=[],yDotGrid[i]=[];for(let j=0;j<=100;j++){const x=xMin+i*xStep,y=yMin+j*yStep,[dx,dy]=vectorField(x,y);xDotGrid[i][j]=isFinite(dx)?dx:NaN,yDotGrid[i][j]=isFinite(dy)?dy:NaN}}const findZeroCrossings=(grid,color)=>{this.ctx.globalAlpha=.4,this.ctx.strokeStyle=color,this.ctx.lineWidth=2,this.ctx.setLineDash([5,5]);for(let i=0;i<100;i++)for(let j=0;j<100;j++){const v00=grid[i][j],v10=grid[i+1][j],v01=grid[i][j+1],v11=grid[i+1][j+1];if(!(isFinite(v00)&&isFinite(v10)&&isFinite(v01)&&isFinite(v11)))continue;const edges=[];if(v00*v10<0){const x=xMin+(i+v00/(v00-v10))*xStep,y=yMin+j*yStep;edges.push([x,y])}if(v10*v11<0){const x=xMin+(i+1)*xStep,y=yMin+(j+v10/(v10-v11))*yStep;edges.push([x,y])}if(v01*v11<0){const x=xMin+(i+v01/(v01-v11))*xStep,y=yMin+(j+1)*yStep;edges.push([x,y])}if(v00*v01<0){const x=xMin+i*xStep,y=yMin+(j+v00/(v00-v01))*yStep;edges.push([x,y])}if(2===edges.length){const[x1,y1]=edges[0],[x2,y2]=edges[1],[cx1,cy1]=this.worldToCanvas(x1,y1),[cx2,cy2]=this.worldToCanvas(x2,y2);this.ctx.beginPath(),this.ctx.moveTo(cx1,cy1),this.ctx.lineTo(cx2,cy2),this.ctx.stroke()}}this.ctx.setLineDash([]),this.ctx.globalAlpha=1};findZeroCrossings(xDotGrid,xNullclineColor),findZeroCrossings(yDotGrid,yNullclineColor)},plot(){const isDark=window.matchMedia("(prefers-color-scheme: dark)").matches;this.ctx.fillStyle=isDark?"#1a1a1a":"white",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid();const xDotExpr=document.getElementById("x-dot").value,yDotExpr=document.getElementById("y-dot").value;if(!xDotExpr||!yDotExpr)return void console.log("Please enter both equations");const vectorField=this.createVectorField(xDotExpr,yDotExpr),xMin=parseFloat(document.getElementById("x-min").value),xMax=parseFloat(document.getElementById("x-max").value),yMin=parseFloat(document.getElementById("y-min").value),yMax=parseFloat(document.getElementById("y-max").value),resolution=parseInt(document.getElementById("resolution").value),xStep=(xMax-xMin)/resolution,yStep=(yMax-yMin)/resolution;let maxMag=0;for(let i=0;i<=resolution;i++)for(let j=0;j<=resolution;j++){const x=xMin+i*xStep,y=yMin+j*yStep,[dx,dy]=vectorField(x,y),mag=Math.sqrt(dx*dx+dy*dy);isFinite(mag)&&mag>maxMag&&(maxMag=mag)}for(let i=0;i<=resolution;i++)for(let j=0;j<=resolution;j++){const x=xMin+i*xStep,y=yMin+j*yStep,[dx,dy]=vectorField(x,y);if(isFinite(dx)&&isFinite(dy)){const color=`hsl(${240-120*(Math.sqrt(dx*dx+dy*dy)/maxMag)}, 70%, 50%)`;this.drawArrow(x,y,dx,dy,color,.8)}}document.getElementById("show-nullclines").checked&&(this.plotNullclines(vectorField),this.drawLegend()),this.trajectories.forEach((traj,idx)=>{const steps=this.calculateTrajectorySteps(traj.tMax),trajectory=this.computeTrajectory(vectorField,traj.x0,traj.y0,traj.tMax,steps);traj.trajectoryData=trajectory,traj.steps=steps,this.ctx.strokeStyle=traj.color,this.ctx.lineWidth=2.5,this.ctx.beginPath(),trajectory.forEach(([x,y],i)=>{const[cx,cy]=this.worldToCanvas(x,y);0===i?this.ctx.moveTo(cx,cy):this.ctx.lineTo(cx,cy)}),this.ctx.stroke();const[cx0,cy0]=this.worldToCanvas(traj.x0,traj.y0);if(this.ctx.fillStyle=traj.color,this.ctx.beginPath(),this.ctx.arc(cx0,cy0,6,0,2*Math.PI),this.ctx.fill(),this.ctx.strokeStyle="white",this.ctx.lineWidth=2,this.ctx.stroke(),trajectory.length>0){const[xEnd,yEnd]=trajectory[trajectory.length-1],[cxEnd,cyEnd]=this.worldToCanvas(xEnd,yEnd);this.ctx.fillStyle=traj.color,this.ctx.beginPath(),this.ctx.moveTo(cxEnd,cyEnd-8),this.ctx.lineTo(cxEnd-6,cyEnd+4),this.ctx.lineTo(cxEnd+6,cyEnd+4),this.ctx.closePath(),this.ctx.fill(),this.ctx.strokeStyle="white",this.ctx.lineWidth=2,this.ctx.stroke()}}),this.trajectories.length>0&&this.plotTimeSeries()},plotTimeSeries(){document.getElementById("subplots-wrapper").style.display="block";const isDark=window.matchMedia("(prefers-color-scheme: dark)").matches,bgColor=isDark?"#1a1a1a":"white",textColor=isDark?"#e0e0e0":"#333",gridColor=isDark?"rgba(255, 255, 255, 0.1)":"rgba(0, 0, 0, 0.1)";this.ctxXvsT.fillStyle=bgColor,this.ctxXvsT.fillRect(0,0,this.canvasXvsT.width,this.canvasXvsT.height),this.plotTimeSeriesHelper(this.canvasXvsT,this.ctxXvsT,"x",textColor,gridColor),this.ctxYvsT.fillStyle=bgColor,this.ctxYvsT.fillRect(0,0,this.canvasYvsT.width,this.canvasYvsT.height),this.plotTimeSeriesHelper(this.canvasYvsT,this.ctxYvsT,"y",textColor,gridColor)},plotTimeSeriesHelper(canvas,ctx,variable,textColor,gridColor){const width=canvas.width,height=canvas.height;let globalMin=1/0,globalMax=-1/0,maxTime=0;this.trajectories.forEach(traj=>{const idx="x"===variable?0:1;traj.trajectoryData.forEach(point=>{const value=point[idx];isFinite(value)&&(globalMin=Math.min(globalMin,value),globalMax=Math.max(globalMax,value))}),maxTime=Math.max(maxTime,traj.tMax)});const range=globalMax-globalMin;globalMin-=.1*range,globalMax+=.1*range,ctx.strokeStyle=gridColor,ctx.lineWidth=1;for(let i=0;i<=5;i++){const y=50+(height-100)*i/5;ctx.beginPath(),ctx.moveTo(50,y),ctx.lineTo(width-50,y),ctx.stroke();const x=50+(width-100)*i/5;ctx.beginPath(),ctx.moveTo(x,50),ctx.lineTo(x,height-50),ctx.stroke()}ctx.strokeStyle=textColor,ctx.lineWidth=2,ctx.beginPath(),ctx.moveTo(50,50),ctx.lineTo(50,height-50),ctx.lineTo(width-50,height-50),ctx.stroke(),ctx.fillStyle=textColor,ctx.font="bold 14px monospace",ctx.textAlign="center",ctx.textBaseline="top",ctx.fillText(`${variable} vs t`,width/2,10),ctx.font="12px monospace",ctx.fillText("t",width-50+15,height-50+5),ctx.save(),ctx.translate(15,height/2),ctx.rotate(-Math.PI/2),ctx.fillText(variable,0,0),ctx.restore(),ctx.font="10px monospace",ctx.textAlign="center",ctx.textBaseline="top";for(let i=0;i<=5;i++){const t=maxTime*i/5,x=50+(width-100)*i/5;ctx.fillText(t.toFixed(1),x,height-50+5)}ctx.textAlign="right",ctx.textBaseline="middle";for(let i=0;i<=5;i++){const value=globalMax-(globalMax-globalMin)*i/5,y=50+(height-100)*i/5;ctx.fillText(value.toFixed(2),45,y)}this.trajectories.forEach(traj=>{ctx.strokeStyle=traj.color,ctx.lineWidth=2,ctx.beginPath();const idx="x"===variable?0:1,dt=traj.tMax/traj.steps;traj.trajectoryData.forEach((point,i)=>{const t=i*dt,value=point[idx];if(isFinite(value)){const x=50+t/maxTime*(width-100),y=50+(1-(value-globalMin)/(globalMax-globalMin))*(height-100);0===i?ctx.moveTo(x,y):ctx.lineTo(x,y)}}),ctx.stroke()})},addTrajectory(){const x0=parseFloat(document.getElementById("traj-x").value),y0=parseFloat(document.getElementById("traj-y").value),tMax=parseFloat(document.getElementById("traj-time").value),integrateBackward=document.getElementById("backward-integration").checked;if(!isFinite(x0)||!isFinite(y0)||!isFinite(tMax))return void alert("Please enter valid numbers for the trajectory");const colors=["#e74c3c","#3498db","#2ecc71","#f39c12","#9b59b6","#1abc9c"],color=colors[this.trajectories.length%colors.length];this.trajectories.push({x0:x0,y0:y0,tMax:tMax,color:color,integrateBackward:integrateBackward}),this.updateTrajectoryList(),this.plot()},removeTrajectory(index){this.trajectories.splice(index,1),this.updateTrajectoryList(),0===this.trajectories.length&&(document.getElementById("subplots-wrapper").style.display="none"),this.plot()},clearTrajectories(){this.trajectories=[],this.updateTrajectoryList(),document.getElementById("subplots-wrapper").style.display="none",this.plot()},updateTrajectoryList(){const list=document.getElementById("trajectory-list"),clearBtn=document.getElementById("clear-traj-btn");if(0===this.trajectories.length)return list.innerHTML="",void(clearBtn.style.display="none");clearBtn.style.display="block",list.innerHTML=this.trajectories.map((traj,idx)=>`\n                <div class="trajectory-item">\n                    <span style="color: ${traj.color}; font-weight: bold;">\n                        ● (${traj.x0.toFixed(2)}, ${traj.y0.toFixed(2)})${traj.integrateBackward?" ⟲":""}\n                    </span>\n                    <button class="plotter-button" onclick="app.removeTrajectory(${idx})">Remove</button>\n                </div>\n            `).join("")}},originalPlot=app.plot;app.plot=function(){const isDark=window.matchMedia("(prefers-color-scheme: dark)").matches;this.ctx.fillStyle=isDark?"#1a1a1a":"white",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid();const xDotExpr=document.getElementById("x-dot").value,yDotExpr=document.getElementById("y-dot").value;if(!xDotExpr||!yDotExpr)return void console.log("Please enter both equations");const vectorField=this.createVectorField(xDotExpr,yDotExpr),xMin=parseFloat(document.getElementById("x-min").value),xMax=parseFloat(document.getElementById("x-max").value),yMin=parseFloat(document.getElementById("y-min").value),yMax=parseFloat(document.getElementById("y-max").value),resolution=parseInt(document.getElementById("resolution").value),xStep=(xMax-xMin)/resolution,yStep=(yMax-yMin)/resolution;let maxMag=0;for(let i=0;i<=resolution;i++)for(let j=0;j<=resolution;j++){const x=xMin+i*xStep,y=yMin+j*yStep,[dx,dy]=vectorField(x,y),mag=Math.sqrt(dx*dx+dy*dy);isFinite(mag)&&mag>maxMag&&(maxMag=mag)}for(let i=0;i<=resolution;i++)for(let j=0;j<=resolution;j++){const x=xMin+i*xStep,y=yMin+j*yStep,[dx,dy]=vectorField(x,y);if(isFinite(dx)&&isFinite(dy)){const color=`hsl(${240-120*(Math.sqrt(dx*dx+dy*dy)/maxMag)}, 70%, 50%)`;this.drawArrow(x,y,dx,dy,color,.8)}}if(document.getElementById("show-nullclines").checked&&(this.plotNullclines(vectorField),this.drawLegend()),this.trajectories.forEach((traj,idx)=>{const steps=this.calculateTrajectorySteps(traj.tMax),forwardTrajectory=this.computeTrajectory(vectorField,traj.x0,traj.y0,traj.tMax,steps);let combinedTrajectory=forwardTrajectory;if(traj.integrateBackward){const backwardVectorField=(x,y)=>{const[dx,dy]=vectorField(x,y);return[-dx,-dy]};combinedTrajectory=[...this.computeTrajectory(backwardVectorField,traj.x0,traj.y0,traj.tMax,steps).slice().reverse(),...forwardTrajectory.slice(1)]}traj.trajectoryData=forwardTrajectory,traj.steps=steps,this.ctx.strokeStyle=traj.color,this.ctx.lineWidth=2.5,this.ctx.beginPath(),combinedTrajectory.forEach(([x,y],i)=>{const[cx,cy]=this.worldToCanvas(x,y);0===i?this.ctx.moveTo(cx,cy):this.ctx.lineTo(cx,cy)}),this.ctx.stroke();const[cx0,cy0]=this.worldToCanvas(traj.x0,traj.y0);if(this.ctx.fillStyle=traj.color,this.ctx.beginPath(),this.ctx.arc(cx0,cy0,6,0,2*Math.PI),this.ctx.fill(),this.ctx.strokeStyle="white",this.ctx.lineWidth=2,this.ctx.stroke(),forwardTrajectory.length>0){const[xEnd,yEnd]=forwardTrajectory[forwardTrajectory.length-1],[cxEnd,cyEnd]=this.worldToCanvas(xEnd,yEnd);this.ctx.fillStyle=traj.color,this.ctx.beginPath(),this.ctx.moveTo(cxEnd,cyEnd-8),this.ctx.lineTo(cxEnd-6,cyEnd+4),this.ctx.lineTo(cxEnd+6,cyEnd+4),this.ctx.closePath(),this.ctx.fill(),this.ctx.strokeStyle="white",this.ctx.lineWidth=2,this.ctx.stroke()}}),this.jacobianPoint){const[jx,jy]=this.worldToCanvas(this.jacobianPoint.x,this.jacobianPoint.y),isDark=window.matchMedia("(prefers-color-scheme: dark)").matches,markerColor=isDark?"#FFD700":"#FF6B00";this.ctx.strokeStyle=markerColor,this.ctx.lineWidth=2.5;const size=12;this.ctx.beginPath(),this.ctx.moveTo(jx-size,jy),this.ctx.lineTo(jx+size,jy),this.ctx.stroke(),this.ctx.beginPath(),this.ctx.moveTo(jx,jy-size),this.ctx.lineTo(jx,jy+size),this.ctx.stroke(),this.ctx.fillStyle=markerColor,this.ctx.beginPath(),this.ctx.arc(jx,jy,4,0,2*Math.PI),this.ctx.fill(),this.ctx.strokeStyle=isDark?"#000":"#FFF",this.ctx.lineWidth=1,this.ctx.stroke()}this.trajectories.length>0&&this.plotTimeSeries()},window.addEventListener("load",()=>{app.init()});